================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-06-19T11:54:45.367Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
Cargo.toml
src/app.rs
src/main.rs
src/models/appcommands.rs
src/models/mod.rs
src/models/subtask.rs
src/models/taskitem.rs
src/ui/main.rs
src/ui/mod.rs
src/ui/sidebar.rs
src/ui/style.rs
src/ui/topbar.rs
src/utils/mod.rs

================================================================
Repository Files
================================================================

================
File: .gitignore
================
target/
.idea/
README.md
.agent/

================
File: Cargo.toml
================
[package]
name = "my-app"
version = "0.1.0"
edition = "2021"

[dependencies]
eframe = { version = "0.31.1", features = ["persistence"] }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
catppuccin-egui = { version = "5.5.0", default-features = false, features = ["egui31"] }
rfd = "0.15.3"
anyhow = "1.0.98"

================
File: src/app.rs
================
use crate::models::appcommands::AppCommands;
use crate::models::taskitem::TaskItem;
use crate::ui::main::Main;
use crate::ui::sidebar::Sidebar;
use crate::ui::style::{get_font, set_styles};
use crate::ui::topbar::Topbar;
use eframe::egui::Color32;
use eframe::*;
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize, Default, Serialize)]
pub struct MyApp {
    project_name: String,
    #[serde(skip)]
    tasks: Vec<TaskItem>,
    cwd: String,
    #[serde(skip)]
    main: Main,
    #[serde(skip)]
    topbar: Topbar,
    #[serde(skip)]
    sidebar: Sidebar,
    #[serde(skip)]
    open_dir_window: bool,
    #[serde(skip)]
    selected_directory: Option<PathBuf>,
}

impl MyApp {
    pub fn new(cc: &CreationContext<'_>) -> Self {
        // Set Global Styles
        set_styles(cc);
        // Sets The Font Globally
        cc.egui_ctx.set_fonts(get_font());

        let mut app = if let Some(storage) = cc.storage {
            get_value(storage, eframe::APP_KEY).unwrap_or_default()
        } else {
            Self::default()
        };

        if app.cwd.is_empty() || !Path::new(&app.cwd).exists() {
            app.open_dir_window = true;
        } else {
            let dir_path = format!("{}/.agent/", { &app.cwd });
            if !Path::new(&dir_path).exists() {
                app.open_dir_window = true;
            } else {
                app.load_project();
            }
        }

        Self {
            main: Main,
            topbar: Topbar,
            sidebar: Sidebar,
            ..app
        }
    }

    fn load_tasks(&mut self) {
        self.tasks.clear();
        let dir_data = fs::read_dir(format!("{}/.agent/", self.cwd)).unwrap();
        let task_files: Vec<_> = dir_data
            .filter_map(|d| d.ok())
            .filter(|entry| {
                entry
                    .file_name()
                    .to_str()
                    .map(|name| name.contains("task_"))
                    .unwrap_or(false)
            })
            .collect();

        for entry in task_files {
            let file_name = format!(
                "{}/.agent/{}",
                self.cwd,
                entry.file_name().to_string_lossy()
            );
            if let Ok(val) = fs::read_to_string(file_name) {
                if let Ok(task) = serde_json::from_str::<TaskItem>(val.as_str()) {
                    self.tasks.push(task);
                }
            }
        }
    }

    fn create_project(&mut self) {
        let agent_dir = format!("{}/.agent/", self.cwd);
        if let Err(_) = fs::create_dir_all(agent_dir) {
            return;
        }
        let ft_create = format!("{}/.agent/data.json", self.cwd);
        let data = serde_json::json!({
            "project_name":"Project",
            "cwd":self.cwd
        });
        if let Ok(_) = fs::write(ft_create, serde_json::to_string_pretty(&data).unwrap()) {
            self.load_project()
        }
    }

    pub fn load_project(&mut self) {
        let data_file = format!("{}/.agent/data.json", self.cwd);
        if let Ok(val) = fs::read_to_string(data_file) {
            let data = serde_json::from_str::<MyApp>(val.as_str()).unwrap();
            self.project_name = data.project_name;
            self.cwd = data.cwd;
        }
        self.load_tasks();
    }

    fn choose_dialog(&mut self, ctx: &egui::Context) {
        egui::Window::new("Select/Open a Project")
            .resizable(true)
            .collapsible(false)
            .default_width(600.0)
            .show(ctx, |ui| {
                ui.heading("Select Project Directory");
                if ui.button("Browse...").clicked(){
                    if let Some(val) = rfd::FileDialog::new().pick_folder(){
                        self.selected_directory = Some(val)
                    }
                }

                if let Some(ref dir) = self.selected_directory{
                    ui.add_space(20.0);
                    ui.label(format!("Selected Directory : {}",dir.to_string_lossy()));

                    let folder = dir.join(".agent");
                    if folder.exists() {
                        ui.colored_label(Color32::GREEN,"Found existing project (.agent), Please click continue to open the project");
                        if ui.button("Continue").clicked() {
                            self.cwd = dir.to_string_lossy().to_string();
                            self.load_project();
                            self.selected_directory = None;
                            self.open_dir_window = false;
                        }
                    }else {
                        ui.colored_label(Color32::RED,"Click continue to initialize a new project");
                        if ui.button("Continue").clicked() {
                            self.cwd = dir.to_string_lossy().to_string();
                            self.create_project();
                            self.selected_directory = None;
                            self.open_dir_window = false;
                        }
                    }
                }
            });
    }

    pub fn handle_action(&mut self, command: AppCommands) {
        match command {
            AppCommands::OpenNewProject => {
                self.open_dir_window = true;
            },
        }
    }
}

impl App for MyApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut Frame) {
        catppuccin_egui::set_theme(&ctx, catppuccin_egui::LATTE);

        if self.open_dir_window {
            self.choose_dialog(&ctx);
        } else {
            if let Some(command) = self.sidebar.render(&ctx) {
                self.handle_action(command);
            }
            let (tasks, project_name) = (&self.tasks, &self.project_name);
            self.topbar.render(&ctx, project_name);
            self.main.render(&ctx, tasks);
        }
    }

    fn save(&mut self, storage: &mut dyn Storage) {
        set_value(storage, eframe::APP_KEY, self)
    }
}

================
File: src/main.rs
================
use eframe::*;
mod app;
mod models;
mod ui;
mod utils;

use app::MyApp;

fn main(){
    let options = NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_maximized(true)
            .with_fullscreen(false),
        persist_window: true,
        ..NativeOptions::default()

    };
    run_native(
        "Project Little Star",
        options,
        Box::new(|cc| {
            Ok(Box::new(MyApp::new(cc)))
        }),
    ).expect("Failed to start the application")
}

================
File: src/models/appcommands.rs
================
pub enum AppCommands{
    OpenNewProject,
}

================
File: src/models/mod.rs
================
pub mod subtask;
pub mod taskitem;
pub mod appcommands;

================
File: src/models/subtask.rs
================
use serde::{Serialize, Deserialize};

#[derive(Debug,Deserialize,Serialize)]
pub struct SubTask{

}

impl SubTask{

}

================
File: src/models/taskitem.rs
================
use crate::models::subtask::SubTask;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct TaskItem {
    pub title: String,
    pub short_desc: String,
    pub description: String,
    pub sub_tasks: Vec<SubTask>,
    pub status: String,
}

impl TaskItem {}

================
File: src/ui/main.rs
================
use crate::models::taskitem::TaskItem;
use eframe::egui;
use eframe::epaint::Shadow;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Main;
impl Main {
    pub fn render(&mut self, ctx: &egui::Context, tasks: &[TaskItem]) {
        egui::CentralPanel::default().show(ctx, |ui| {
            egui::ScrollArea::vertical().show(ui, |ui| {
                for task in tasks {
                    // Create a frame with border and shadow
                    let frame = egui::Frame::default()
                        .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgb(0, 0, 0)))
                        .shadow(Shadow {
                            color: egui::Color32::from_black_alpha(80),
                            offset:[1,1],
                            blur:4,
                            spread:1
                        })
                        .inner_margin(egui::Margin::same(8))
                        .outer_margin(egui::Margin::same(2));

                    frame.show(ui, |ui| {
                        ui.set_width(ui.available_width());

                        ui.horizontal(|ui| {
                            let _ = egui::CollapsingHeader::new(&task.title)
                                .default_open(false)
                                .show(ui, |ui| {
                                    ui.label(&task.short_desc);
                                    ui.label(format!("Status: {}", &task.status));
                                });

                            // Push buttons to the right side
                            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                if ui.button("Edit").clicked() {
                                }
                                if ui.button("+").clicked() {
                                }
                                if ui.button("Open").clicked() {
                                }
                            });
                        });
                    });
                    ui.add_space(5.0);
                }
            });
        });
    }

}

================
File: src/ui/mod.rs
================
pub mod style;
pub mod sidebar;
pub mod topbar;
pub mod main;

================
File: src/ui/sidebar.rs
================
use eframe::egui;
use eframe::egui::panel::Side;
use serde::{Deserialize, Serialize};

use crate::models::appcommands::AppCommands;

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Sidebar;
impl Sidebar {
    pub fn render(&mut self, ctx: &egui::Context) -> Option<AppCommands>{
        let mut to_send : Option<AppCommands> = None;
        egui::SidePanel::new(Side::Left, "left_bar")
            .resizable(true)
            .show(ctx, |ui| {
                ui.add_space(13.0);
                ui.vertical_centered(|ui| ui.heading("ZenTask"));
                ui.add_space(7.0);
                ui.separator();
                ui.vertical_centered(|ui| {
                    if ui.button("Add Task").clicked(){
                     // to_send = Some(AppCommands::AddTask)
                    }
                    ui.with_layout(egui::Layout::bottom_up(egui::Align::Center), |ui| {
                        if ui.button("Open New Project").clicked(){
                            to_send = Some(AppCommands::OpenNewProject)
                        }
                        ui.separator();
                    });
                });
            });
        to_send
    }
}

================
File: src/ui/style.rs
================
use eframe::egui;
use eframe::egui::{FontDefinitions, Vec2};

pub fn get_font() -> FontDefinitions {
    let mut fonts = egui::FontDefinitions::default();
    fonts.font_data.insert(
        "space_mono".to_owned(),
        egui::FontData::from_static(include_bytes!("../../assets/space_mono.ttf")).into(),
    );
    fonts
        .families
        .get_mut(&egui::FontFamily::Proportional)
        .unwrap()
        .insert(0, "space_mono".to_owned());
    fonts
}

pub fn set_styles(cc : &eframe::CreationContext<'_> ) {
    cc.egui_ctx.style_mut(|style| {
        style.spacing.button_padding = Vec2::new(10.0, 6.0);
        style.spacing.item_spacing = Vec2::new(6.0, 4.0);
        style.spacing.indent = 20.0;
        style.text_styles.insert(
            egui::TextStyle::Button,
            egui::FontId::new(16.0, egui::FontFamily::Proportional),
        );
        style.text_styles.insert(
            egui::TextStyle::Body,
            egui::FontId::new(15.0, egui::FontFamily::Proportional),
        );
        style.text_styles.insert(
            egui::TextStyle::Heading,
            egui::FontId::new(20.0, egui::FontFamily::Proportional),
        );
    });
    cc.egui_ctx.set_pixels_per_point(1.1);
}

================
File: src/ui/topbar.rs
================
use eframe::egui;
use eframe::egui::panel::TopBottomSide;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Topbar;
impl Topbar {
    pub fn render(&mut self, ctx: &egui::Context,project_name:&String) {
        egui::TopBottomPanel::new(TopBottomSide::Top, "top_bar").show(ctx, |ui| {
            ui.add_space(7.0);
            ui.horizontal(|ui| {
                ui.heading(format!("{project_name}") );
                ui.with_layout(egui::Layout::right_to_left(egui::Align::RIGHT), |ui| {
                    let _ = ui.button("Chat Mode");
                    let _ = ui.button("Plan Mode");
                    let _ = ui.button("Tasks");
                });
            });
            ui.add_space(7.0);
        });
    }
}

================
File: src/utils/mod.rs
================
pub mod io;
